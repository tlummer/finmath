package com.lorenzotorricelli.solex4;





public class Ex4 {

	public static void main(String[] args) {
		
		System.out.println("Exercise 1 \n" );
		
		
		double mu=0.0;
		double sigma=1.0; //I don't know why I am using this value, I liked it
		double prob=0.99;
		NormalRandomVariable normalTestSampler=new NormalRandomVariable(mu,sigma);
		
		
		int numberOfSimulations=100000;
	
		System.out.println("Comparing Emprical mean and std dev to mu and sigma");
		
		System.out.println("Sample mean: "   + normalTestSampler.getSampleMean(numberOfSimulations) );
		System.out.println("Mu: "   + normalTestSampler.getMean() );
		
		System.out.println("Sample std DEv: "   + normalTestSampler.getSampleStdDeviation(numberOfSimulations) );
		System.out.println("Sigma: "   + normalTestSampler.getStdDeviation() );
		
		System.out.println("\n" );
		
		
		double y= normalTestSampler.quantileFunction(prob);
		System.out.println("The quantile of a probability of " + prob + " of a  normal random variable of mean " + mu + " and std deviation " + sigma+ " is " + y);

		System.out.println("\n");
		
		System.out.println("The cumulative distribution  function at " + y + " is " + normalTestSampler.cdfFunction(y));



		
		System.out.println("Exercise 2 \n" );
		
		double lambda=0.2;
		int numberOfExponentialDrawings=1000;
		double confidenceLevel=0.95;
		int numberOfIntervalSimulations=1000;

		ExponentialRandomVariable exponential=new ExponentialRandomVariable(lambda);
		
		ChebyshevMeanConfidenceInterval cheb=new ChebyshevMeanConfidenceInterval(exponential, numberOfExponentialDrawings );
		CLTMeanConfidenceInterval clt=new CLTMeanConfidenceInterval(exponential, numberOfExponentialDrawings);

		System.out.println("The analytical value of lambda is " + exponential.getLambda());
		
		System.out.println("\n" );




		System.out.println("The Chebyshev condifence interval boundaries at a " + confidenceLevel*100+ "% confidence level  for lambda  after " + numberOfExponentialDrawings+" drawings are \n" + 
				exponential.getParamterLoweerBoundConfidenceInterval(confidenceLevel, cheb) + " and " + exponential.getParamterUpperBoundConfidenceInterval(confidenceLevel, cheb));
		System.out.println("\n");

		System.out.println("The CLT condifence interval boundaries at a " + confidenceLevel*100+ "% confidence levelfor lambda after "  + numberOfExponentialDrawings+" drawings are \n" + 
				exponential.getParamterLoweerBoundConfidenceInterval(confidenceLevel, clt) + " and " +  exponential.getParamterUpperBoundConfidenceInterval(confidenceLevel, clt));
		System.out.println("\n");




		System.out.println("\n" );

		System.out.println("The frequence of lambda being in the Chebyshev confidence interval is "
				+ cheb.frequenceOfInterval(numberOfIntervalSimulations, confidenceLevel)*100 +"%");

		System.out.println("The frequence of lambda being in the CLT confidence interval is " + 
				clt.frequenceOfInterval(numberOfIntervalSimulations, confidenceLevel)*100 +"%");

		System.out.println("\n" );

		
		

	
		System.out.println("\n");

		//BoxMuller b=new BoxMuller(mu, si);


		System.out.println("Exercise 3 \n");

		double sum=0.0;

		long lStartTime = System.currentTimeMillis();
		for(int i=0; i<numberOfSimulations; i++){
			if(normalTestSampler.generateBoxMuller().getFirstValue()<mu && normalTestSampler.generateBoxMuller().getSecondValue()<mu){
				sum++;
	}
		}
		long lEndTime = System.currentTimeMillis();
	    System.out.println("The frequence of both the rv generated by the B-M algorithm to be less than mu is: "+ sum/numberOfSimulations);
		System.out.println("Elapsed time:" + (lEndTime-lStartTime) + " ms" );


		sum=0.0;
		lStartTime = System.currentTimeMillis();

		for(int i=0; i<numberOfSimulations; i++){

			if(normalTestSampler.generateBivariateNormal().getFirstValue()<mu &&  normalTestSampler.generateBivariateNormal().getSecondValue()<mu){
					sum++;
			}
	}
		lEndTime = System.currentTimeMillis();

		System.out.println("The frequence of both the rv independently sampled from the inverse cdf to be less than mu is: "+ sum/numberOfSimulations);
		System.out.println("Elapsed time:" + (lEndTime-lStartTime) + " ms" );

		
	}
	


	}	




